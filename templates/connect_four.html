{% extends "layout.html" %}

{% block title %}Connect Four - Juega contra IA{% endblock %}

{% block head_styles %}
<style>
    .board-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 20px;
        position: relative;
    }
    
    .board {
        background-color: #1a57b0;
        border-radius: 10px;
        padding: 15px;
        display: inline-grid;
        grid-template-columns: repeat(7, 1fr);
        grid-gap: 8px;
        box-shadow: 0 8px 16px rgba(0,0,0,0.3);
    }
    
    .cell {
        width: 60px;
        height: 60px;
        background-color: #fff;
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .cell:hover {
        background-color: #eaeaea;
    }
    
    .cell.player {
        background-color: #e63946;
        cursor: default;
    }
    
    .cell.ai {
        background-color: #ffbe0b;
        cursor: default;
    }
    
    .column-selector {
        width: 60px;
        height: 30px;
        background-color: rgba(255,255,255,0.3);
        border-radius: 5px;
        margin-bottom: 5px;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .column-selector:hover {
        background-color: rgba(255,255,255,0.5);
    }
    
    .game-info {
        background-color: #fff;
        border-radius: 10px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        height: auto;
    }
    
    .turn-indicator {
        text-align: center;
        font-size: 1.2rem;
        padding: 10px;
        margin-bottom: 15px;
        border-radius: 5px;
    }
    
    .player-turn {
        background-color: rgba(230, 57, 70, 0.2);
        border: 1px solid #e63946;
    }
    
    .ai-turn {
        background-color: rgba(255, 190, 11, 0.2);
        border: 1px solid #ffbe0b;
    }
    
    .game-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 15px;
    }
    
    .winner-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px 40px;
        border-radius: 10px;
        font-size: 1.5rem;
        z-index: 10;
        display: none;
    }
    
    /* Animaci√≥n para la ficha cayendo */
    @keyframes dropToken {
        from { transform: translateY(-300px); }
        to { transform: translateY(0); }
    }
    
    .animate-drop {
        animation: dropToken 0.5s ease-in;
    }
    
    /* Estilo para la explicaci√≥n del modelo */
    .model-explanation {
        margin-top: 30px;
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 10px;
        padding: 20px;
    }
    
    .code-toggle {
        cursor: pointer;
        color: #1a57b0;
        text-decoration: underline;
    }
    
    .difficulty-selector {
        margin-bottom: 20px;
        color: white;
    }
    
    /* Ajustes responsive para que el panel de info no se superponga */
    @media (max-width: 991px) {
        .game-info {
            margin-top: 30px;
        }
    }
</style>
{% endblock %}

{% block content %}
<h2 class="text-white fall-element fall-delay-1">Connect Four - Juega contra IA</h2>
<p class="lead text-white fall-element fall-delay-1">¬°Intenta conectar 4 fichas en l√≠nea antes que la IA!</p>

<!-- Selector de dificultad -->
<div class="difficulty-selector fall-element fall-delay-2">
    <label for="difficultySelector" class="text-white mb-2">Nivel de dificultad:</label>
    <select id="difficultySelector" class="form-select mb-3" style="max-width: 200px;">
        <option value="normal" selected>Normal</option>
        <option value="hard">Avanzado</option>
    </select>
    <p class="text-white-50 small">Ambos niveles utilizan el modelo de ML, con diferentes configuraciones.</p>
</div>

<div class="row fall-element fall-delay-2">
    <div class="col-lg-8 col-md-12 mb-4">
        <!-- Contenedor del tablero -->
        <div class="board-container">
            <!-- Mensaje de ganador -->
            <div class="winner-message" id="winnerMessage"></div>
            
            <!-- Selectores de columna - AHORA ENCIMA DEL TABLERO -->
            <div class="mb-2">
                <div id="columnSelectors" class="d-flex gap-2 justify-content-center">
                    <div class="column-selector" data-column="0"></div>
                    <div class="column-selector" data-column="1"></div>
                    <div class="column-selector" data-column="2"></div>
                    <div class="column-selector" data-column="3"></div>
                    <div class="column-selector" data-column="4"></div>
                    <div class="column-selector" data-column="5"></div>
                    <div class="column-selector" data-column="6"></div>
                </div>
            </div>
            
            <!-- Tablero de juego -->
            <div class="board" id="gameBoard">
                <!-- Las celdas se generar√°n con JavaScript -->
            </div>
        </div>
        
        <!-- Botones de juego -->
        <div class="game-buttons fall-element fall-delay-3">
            <button id="resetButton" class="btn btn-primary">Reiniciar Juego</button>
            <button id="aiFirstButton" class="btn btn-secondary">IA Primero</button>
        </div>
    </div>
    
    <div class="col-lg-4 col-md-12">
        <!-- Informaci√≥n del juego - AHORA AL LADO DEL TABLERO -->
        <div class="game-info fall-element fall-delay-3">
            <h4>Estado del Juego</h4>
            <div class="turn-indicator player-turn" id="turnIndicator">Tu turno</div>
            
            <div class="game-stats text-dark">
                <p><strong>Fichas jugadas:</strong> <span id="moveCount">0</span></p>
                <p><strong>Tiempo de juego:</strong> <span id="gameTime">00:00</span></p>
            </div>
        </div>
    </div>
</div>

<!-- Explicaci√≥n del modelo -->
<div class="jumbotron fall-element fall-delay-4">
    <h4>Acerca del Modelo de Machine Learning</h4>
    <p>Este juego utiliza exclusivamente un √°rbol de decisi√≥n entrenado con datos de partidas de Connect Four para predecir el mejor movimiento en cada situaci√≥n.</p>
    
    <div class="row mt-3">
        <div class="col-md-6">
            <h5>Niveles de Dificultad</h5>
            <ul>
                <li><strong>Normal:</strong> Utiliza el modelo con un 30% de aleatoriedad para hacerlo menos predecible.</li>
                <li><strong>Avanzado:</strong> Utiliza el modelo de forma pura para obtener sus mejores predicciones.</li>
            </ul>
        </div>
        <div class="col-md-6">
            <h5>Estad√≠sticas del Modelo</h5>
            <p>El modelo fue entrenado con un conjunto de datos de <strong>190,000 ejemplos</strong> y alcanz√≥ una precisi√≥n del <strong>100%</strong> en el conjunto de prueba.</p>
        </div>
    </div>
    
    <p class="code-toggle" data-bs-toggle="collapse" data-bs-target="#modelCode">
        <i class="bi bi-code-slash"></i> Ver c√≥digo de entrenamiento
    </p>
    
    <div class="collapse" id="modelCode">
        <pre class="bg-dark text-light p-3 rounded" style="overflow-x: auto;"><code>
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier

# Carga de datos
df = pd.read_csv("connect_four_dataset.csv")

# Separaci√≥n de caracter√≠sticas y variable objetivo
X, y = remove_labels(df, "move")

# Preprocesamiento
X_encoded = pd.get_dummies(X, drop_first=False)

# Divisi√≥n en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X_encoded, y, test_size=0.4, random_state=42)

# Entrenamiento del modelo DecisionTree
clf_tree = DecisionTreeClassifier(max_depth=4, random_state=41)
clf_tree.fit(X_train, y_train)

# Guardado del modelo entrenado
import cloudpickle
with open('modelo_connect-four.pkl', 'wb') as f:
    cloudpickle.dump(clf_tree, f)</code></pre>
    </div>
    
    <p class="code-toggle mt-3" data-bs-toggle="collapse" data-bs-target="#datasetCode">
        <i class="bi bi-database"></i> Ver generaci√≥n del dataset
    </p>
    
    <div class="collapse" id="datasetCode">
        <pre class="bg-dark text-light p-3 rounded" style="overflow-x: auto;"><code>
from easyAI import TwoPlayerGame, AI_Player, Negamax
import random
import csv

ROWS, COLS = 6, 7

class ConnectFour(TwoPlayerGame):
    def __init__(self, players):
        self.players = players
        self.board = [['.' for _ in range(COLS)] for _ in range(ROWS)]
        self.current_player = 1
        self.history = []  # Para almacenar jugadas
        
    def possible_moves(self):
        return [str(c) for c in range(COLS) if self.board[0][c] == '.']
        
    def make_move(self, move):
        col = int(move)
        for row in reversed(range(ROWS)):
            if self.board[row][col] == '.':
                self.board[row][col] = self.get_current_player_token()
                self.history.append((self.get_flattened_board(), col))
                break
                
    def unmake_move(self, move):
        col = int(move)
        for row in range(ROWS):
            if self.board[row][col] != '.':
                self.board[row][col] = '.'
                self.history.pop()
                break
                
    def is_over(self):
        return self.winner() is not None or not any('.' in row for row in self.board)
        
    def show(self):
        for row in self.board:
            print(' '.join(row))
        print("0 1 2 3 4 5 6\n")
        
    def scoring(self):
        winner = self.winner()
        if winner == self.get_current_player_token():
            return 100
        elif winner == self.get_opponent_token():
            return -100
        return 0
        
    def get_current_player_token(self):
        return ['X', 'O'][self.current_player - 1]
        
    def get_opponent_token(self):
        return ['O', 'X'][self.current_player - 1]
        
    def get_flattened_board(self):
        return [cell for row in self.board for cell in row]
        
    def winner(self):
        directions = [(1, 0), (0, 1), (1, 1), (1, -1)]
        for r in range(ROWS):
            for c in range(COLS):
                token = self.board[r][c]
                if token == '.':
                    continue
                for dr, dc in directions:
                    if all(
                        0 <= r + i * dr < ROWS and
                        0 <= c + i * dc < COLS and
                        self.board[r + i * dr][c + i * dc] == token
                        for i in range(4)
                    ):
                        return token
        return None

# üîÑ Simulaci√≥n de partidas y generaci√≥n de dataset
dataset = []
n_partidas = 10000  # Puedes aumentar esto si quieres m√°s datos

for _ in range(n_partidas):
    game = ConnectFour([AI_Player(Negamax(2)), AI_Player(Negamax(2))])
    game.play()

    ganador = game.winner()  # 'X', 'O' o None
    if ganador not in ('X', 'O'):
        continue  # Si fue empate, no guardamos nada

    for i, (estado, move) in enumerate(game.history):
        jugador = 'X' if i % 2 == 0 else 'O'  # Turnos alternos

        if jugador == ganador:
            fila = estado + [move, 1]  # Solo guardamos jugadas ganadoras
            dataset.append(fila)

# Guardar en CSV
header = [f'cell_{i}' for i in range(ROWS * COLS)] + ['move']
with open("connect_four_dataset.csv", "w", newline="") as f:
    writer = csv.writer(f)
    writer.writerow(header)
    writer.writerows(dataset)

print(f"‚úî Dataset generado con {len(dataset)} jugadas ganadoras guardadas.")</code></pre>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Constantes
        const ROWS = 6;
        const COLS = 7;
        const EMPTY = '.';
        const PLAYER = 'O';
        const AI = 'X';
        
        // Variables del juego
        let board = [];
        let currentPlayer = PLAYER;
        let gameOver = false;
        let gameStartTime = new Date();
        let gameTimer;
        let difficulty = 'normal';
        
        // Referencias a elementos del DOM
        const gameBoard = document.getElementById('gameBoard');
        const turnIndicator = document.getElementById('turnIndicator');
        const moveCount = document.getElementById('moveCount');
        const gameTime = document.getElementById('gameTime');
        const winnerMessage = document.getElementById('winnerMessage');
        const resetButton = document.getElementById('resetButton');
        const aiFirstButton = document.getElementById('aiFirstButton');
        const columnSelectors = document.querySelectorAll('.column-selector');
        
        // Inicializar tablero
        function initBoard() {
            board = [];
            
            // Crear array 2D para el tablero
            for (let r = 0; r < ROWS; r++) {
                let row = [];
                for (let c = 0; c < COLS; c++) {
                    row.push(EMPTY);
                }
                board.push(row);
            }
            
            // Limpiar el tablero visual
            gameBoard.innerHTML = '';
            
            // Crear las celdas visuales
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    gameBoard.appendChild(cell);
                }
            }
            
            // Reiniciar variables del juego
            currentPlayer = PLAYER;
            gameOver = false;
            winnerMessage.style.display = 'none';
            turnIndicator.className = 'turn-indicator player-turn';
            turnIndicator.textContent = 'Tu turno';
            moveCount.textContent = '0';
            
            // Reiniciar temporizador
            clearInterval(gameTimer);
            gameStartTime = new Date();
            gameTimer = setInterval(updateGameTime, 1000);
            gameTime.textContent = '00:00';
            
            // Habilitar interacciones
            enableColumnSelectors();
        }
        
        // Actualizar el temporizador del juego
        function updateGameTime() {
            const now = new Date();
            const diff = Math.floor((now - gameStartTime) / 1000);
            const minutes = Math.floor(diff / 60).toString().padStart(2, '0');
            const seconds = (diff % 60).toString().padStart(2, '0');
            gameTime.textContent = `${minutes}:${seconds}`;
        }
        
        // Habilitar selectores de columna
        function enableColumnSelectors() {
            columnSelectors.forEach(selector => {
                selector.style.visibility = 'visible';
            });
        }
        
        // Deshabilitar selectores de columna
        function disableColumnSelectors() {
            columnSelectors.forEach(selector => {
                selector.style.visibility = 'hidden';
            });
        }
        
        // Realizar un movimiento
        function makeMove(col) {
            if (gameOver || currentPlayer !== PLAYER) return;
            
            // Encontrar la primera celda vac√≠a en la columna (de abajo hacia arriba)
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r][col] === EMPTY) {
                    board[r][col] = currentPlayer;
                    updateBoardUI();
                    moveCount.textContent = parseInt(moveCount.textContent) + 1;
                    
                    // Verificar victoria
                    if (checkWin(r, col, currentPlayer)) {
                        gameOver = true;
                        showWinner('¬°Has ganado!');
                        disableColumnSelectors();
                        clearInterval(gameTimer);
                        return;
                    }
                    
                    // Verificar empate
                    if (checkDraw()) {
                        gameOver = true;
                        showWinner('¬°Empate!');
                        disableColumnSelectors();
                        clearInterval(gameTimer);
                        return;
                    }
                    
                    // Cambiar turno
                    currentPlayer = AI;
                    turnIndicator.className = 'turn-indicator ai-turn';
                    turnIndicator.textContent = 'Turno de la IA...';
                    
                    // Hacer que la IA juegue despu√©s de un breve retraso
                    setTimeout(aiMove, 700);
                    return;
                }
            }
        }
        
        // Movimiento de la IA
        function aiMove() {
            if (gameOver) return;
            
            // Obtener estado actual del tablero para enviar al modelo
            const boardState = {};
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const index = r * COLS + c;
                    boardState[index] = board[r][c];
                }
            }
            
            // Siempre usar el modelo ML para predecir el movimiento
            // En modo dif√≠cil, usamos par√°metros m√°s avanzados
            fetch('/connect-four/predict', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    board_state: boardState,
                    difficulty: difficulty
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    makeAIMove(data.move);
                } else {
                    console.error('Error en la predicci√≥n:', data.error);
                    // Si hay error, elegir una columna disponible aleatoria
                    makeRandomMove();
                }
            })
            .catch(error => {
                console.error('Error al llamar a la API:', error);
                // Si hay error, elegir una columna disponible aleatoria
                makeRandomMove();
            });
        }
        
        // Movimiento aleatorio como fallback en caso de error
        function makeRandomMove() {
            const validColumns = [];
            
            // Identificar columnas disponibles
            for (let c = 0; c < COLS; c++) {
                if (board[0][c] === EMPTY) {
                    validColumns.push(c);
                }
            }
            
            if (validColumns.length > 0) {
                // Elegir columna aleatoria entre las disponibles
                const randomColumn = validColumns[Math.floor(Math.random() * validColumns.length)];
                makeAIMove(randomColumn);
            } else {
                // Si no hay columnas disponibles, es un empate
                gameOver = true;
                showWinner('¬°Empate!');
                disableColumnSelectors();
                clearInterval(gameTimer);
            }
        }
        
        // Ejecutar el movimiento elegido por la IA
        function makeAIMove(col) {
            // Encontrar la primera celda vac√≠a en la columna (de abajo hacia arriba)
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r][col] === EMPTY) {
                    board[r][col] = AI;
                    updateBoardUI();
                    moveCount.textContent = parseInt(moveCount.textContent) + 1;
                    
                    // Verificar victoria
                    if (checkWin(r, col, AI)) {
                        gameOver = true;
                        showWinner('La IA ha ganado');
                        disableColumnSelectors();
                        clearInterval(gameTimer);
                        return;
                    }
                    
                    // Verificar empate
                    if (checkDraw()) {
                        gameOver = true;
                        showWinner('¬°Empate!');
                        disableColumnSelectors();
                        clearInterval(gameTimer);
                        return;
                    }
                    
                    // Cambiar turno
                    currentPlayer = PLAYER;
                    turnIndicator.className = 'turn-indicator player-turn';
                    turnIndicator.textContent = 'Tu turno';
                    return;
                }
            }
        }
        
        // Actualizar la interfaz del tablero
        function updateBoardUI() {
            const cells = gameBoard.querySelectorAll('.cell');
            
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                // Eliminar clases previas
                cell.classList.remove('player', 'ai', 'animate-drop');
                void cell.offsetWidth; // Forzar reflow para reiniciar la animaci√≥n
                
                // Agregar clase seg√∫n el estado de la celda
                if (board[row][col] === PLAYER) {
                    cell.classList.add('player', 'animate-drop');
                } else if (board[row][col] === AI) {
                    cell.classList.add('ai', 'animate-drop');
                }
            });
        }
        
        // Verificar victoria
        function checkWin(row, col, player) {
            // Verificar horizontal
            let count = 0;
            for (let c = 0; c < COLS; c++) {
                if (board[row][c] === player) {
                    count++;
                    if (count >= 4) return true;
                } else {
                    count = 0;
                }
            }
            
            // Verificar vertical
            count = 0;
            for (let r = 0; r < ROWS; r++) {
                if (board[r][col] === player) {
                    count++;
                    if (count >= 4) return true;
                } else {
                    count = 0;
                }
            }
            
            // Verificar diagonal /
            count = 0;
            let startRow = row + Math.min(col, row);
            let startCol = col - Math.min(col, row);
            
            while (startRow >= 0 && startCol < COLS) {
                if (startRow < ROWS && board[startRow][startCol] === player) {
                    count++;
                    if (count >= 4) return true;
                } else {
                    count = 0;
                }
                startRow--;
                startCol++;
            }
            
            // Verificar diagonal \
            count = 0;
            startRow = row - Math.min(col, ROWS - 1 - row);
            startCol = col - Math.min(col, ROWS - 1 - row);
            
            while (startRow < ROWS && startCol < COLS) {
                if (startRow >= 0 && board[startRow][startCol] === player) {
                    count++;
                    if (count >= 4) return true;
                } else {
                    count = 0;
                }
                startRow++;
                startCol++;
            }
            
            return false;
        }
        
        // Verificar empate
        function checkDraw() {
            for (let c = 0; c < COLS; c++) {
                if (board[0][c] === EMPTY) {
                    return false;
                }
            }
            return true;
        }
        
        // Mostrar mensaje de ganador
        function showWinner(message) {
            winnerMessage.textContent = message;
            winnerMessage.style.display = 'block';
        }
        
        // Eventos para los selectores de columna
        columnSelectors.forEach(selector => {
            selector.addEventListener('click', function() {
                if (!gameOver && currentPlayer === PLAYER) {
                    const col = parseInt(this.dataset.column);
                    makeMove(col);
                }
            });
        });
        
        // Evento para el bot√≥n de reinicio
        resetButton.addEventListener('click', function() {
            initBoard();
        });
        
        // Evento para el bot√≥n de IA primero
        aiFirstButton.addEventListener('click', function() {
            initBoard();
            currentPlayer = AI;
            turnIndicator.className = 'turn-indicator ai-turn';
            turnIndicator.textContent = 'Turno de la IA...';
            
            // Hacer que la IA juegue despu√©s de un breve retraso
            setTimeout(aiMove, 700);
        });
        
        // Eventos para los selectores de dificultad
        document.getElementById('difficultySelector').addEventListener('change', function() {
            // Actualizar dificultad
            difficulty = this.value;
            
            // Si hay un juego en curso, mostrar mensaje
            if (!gameOver && parseInt(moveCount.textContent) > 0) {
                alert('La dificultad se aplicar√° en el pr√≥ximo juego.');
            }
        });
        
        // Inicializar el juego
        initBoard();
    });
</script>
{% endblock %}